#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



思路：使用双指针，分别指向当前保存数的末尾和遍历数的末尾，从0位置开始向后遍历。

当指向存储的数和遍历的数相等时，遍历指针往后移动直至不相等或者到末尾。

如果没有到达末尾，则将当前遍历的数加到存储的数的末尾，存储数的指针向后移动。

整个过程中用到了两个指针变量，一次循环，时间复杂度为O(n),空间复杂度为O（1）


总结：可以将这两个指针命名为快慢指针，快指针表示遍历到的位置，满指针表示下一个不同元素要填入的下标位置，fast从1遍历至n-1。同时应该考虑到边界情况，比如nums.size()等于0或者1的时候就可以直接返回0或者1。

```C++
int removeDuplicates(vector<int> &nums)
{
    int i = 0;
    int j = 1;
    while (j < nums.size())
    {
        if (nums[j - 1] == nums[j])
        {
            j++;
            continue;
        }

        nums[++i] = nums[j++];
    }
    return ++i;
}	
```



#### [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



思路：同上一样使用双指针，满指针指向下一个要填入数的位置，快指针指向遍历数的位置，这里考虑更宽泛的情况：保留N位相同的数字，那么fast和slow指针直接指向N，因为前N-1个元素中肯定没有N个相同的元素。fast指针从N遍历至容器末尾，判断快指针指向的数字和满指针向前移动N位的数字是否相同，如果相同则移动快指针的位置，如果不同说明快指针指向的数字在满指针保存的数据中小于N个，即还可以向保存的数据中插入数据。然后快指针和满指针同时向后移动，继续遍历。

```
int removeDuplicates(vector<int> &nums)
{
    int N = nums.size();
    if (N <= 2)
        return N;
    int p, q;
    p = q = 2;
    while (q < N)
    {
        if (nums[q] != nums[p - 2])
        {
            nums[p] = nums[q];
            p++;
        }
        q++;
    }
    return p;
}
```

